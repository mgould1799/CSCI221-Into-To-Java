import java.util.*;
import java.io.*;
import java.awt.*;

public class MapDataDrawer
{
  // store map data in grid array
  private int[][] grid; 
  
  // Read 2D array into grid. Data in file "filename", grid is rows x cols
  public MapDataDrawer(String filename, int rows, int cols) throws Exception{
      grid=new int[rows][cols];
      File numFile=new File(filename);
      Scanner gridScanner =new Scanner(numFile);
      //while(gridScanner.hasNextInt())
      //{
      for(int i=0;i<rows;i++)
      {
          for(int j=0;j<cols;j++)
          {
              grid[i][j]=gridScanner.nextInt();
              //System.out.println(grid[i][j]);
            }
        }
    //}

      System.out.println(grid[1][0]);
  }
  
  /**
   * @return the min value in the entire grid
   */
  public int findMin(){
      int min=grid[0][0];
      for(int i=0;i<grid.length;i++)
      {
          for(int j=0;j<grid[i].length;j++)
          {
              if(grid[i][j]<min)
                min=grid[i][j];
            }
        }
        
      return min;  
  }
  
  /**
   * @return the max value in the entire grid
   */
  public int findMax(){
      int max=grid[0][0];
      for(int i=0;i<grid.length;i++)
      {
          for(int j=0;j<grid[i].length;j++)
          {
              if(grid[i][j]>max)
                max=grid[i][j];
            }
        }
      

      return max; 
  }
  
  /**
   * @param col the column of the grid to check
   * @return the index of the row with the lowest value in the given col for the grid
   */
  public  int indexOfMinRow(int col){
      int minCol=grid[0][col];
      int minRow=0;
      for(int i=0;i<grid.length;i++)
      {
          if(grid[i][col]<minCol)
          {
            minCol=grid[i][col];
            minRow=i;
        }
        }
      
      return minRow;  
  }
  
  
  /**
   * DON'T CHANGE THIS CODE, except to uncomment it when you instantiate the grid
   * Draws the grid using the given Graphics object. 
   * Colors should be grayscale values 0-255, scaled based on min/max values in grid
   */
  
  // ******ALERT******
  // Note - until you instantiate a grid, through the constructor, this
  // method will generate a null pointer exception, since there is no grid.length
  // ********************
  public void drawMap(Graphics g){
      
    int minVal = findMin();
    int maxVal = findMax();
    double range = maxVal - minVal;
    
    for(int row=0; row < grid.length; row++){
      for(int col=0; col<grid[0].length; col++){
         int val = (int)(((grid[row][col]-minVal)/range) * 255);
         //g.setColor(new Color(val,255-val,255-val));
         g.setColor(new Color(val,val,val));
         g.fillRect(col,row,1,1);
        }
    }      
  }
  

   /**
   * Find a path from West-to-East starting at given row.
   * Choose a foward step out of 3 possible forward locations, using greedy method described in assignment.
   * @return the total change in elevation traveled from West-to-East
   */
  public int drawLowestElevPath(Graphics g, int row){
    int currY = row; // row in grid of step one
    // draw initial step - column 0, current row (sent in as parameter)
    g.fillRect(0,row,1,1);
    //int row1
    
    // Code to compute next step
    int elevationChange=0;
    
    // draw next step where x is currently column and currY is row in grid
    int x = 0; // the value of x will be generated by a loop that goes through the
    // columns, but for now, need something to put in "paint" statement
    for(int i=0;i<grid[0].length-2&&x<grid[0].length-2&&currY<grid.length-1;x++)
    {
       // if(x<grid.length)
        if(currY==0)//(grid[currY][0]==grid[currY][i])
        {   
            //System.out.println("row"+currY+"col"+x+"  space "+grid[currY][x]);
            
            int change1=Math.abs(grid[currY][x+1]-grid[currY][x]);
            int change2=Math.abs(grid[currY+1][x+1]-grid[currY][x]);
            //System.out.println("forward"+change1);
            //System.out.println("down"+change2);
            if(change1==change2)
            {
               
                x++;
                elevationChange+=change2;
                
            }
             else if(change1<change2)
                {
                    
                    x++;
                    elevationChange+=change1;
                }
              else
              {
                  currY++;
                  x++;
                  elevationChange+=change2;
                }
            }
            
            else if(currY==grid[0].length-1)//(grid[currY][grid[0].length-1]==grid[currY][grid[i)
            {
                //System.out.println("row"+currY+"col"+x+"  space "+grid[currY][x]);
                int c1=Math.abs(grid[currY][x]-grid[currY-1][x+1]);
                //System.out.println("up"+c1);
                int c2=Math.abs(grid[currY][x]-grid[currY][x+1]);
                //System.out.println("forward"+c2);
                    if(c1<c2)
                {
                    currY++;
                    x--;
                    elevationChange+=c1;
                }
                else if(c2<c1)
                {
                    
                    x=x;
                    elevationChange+=c2;
                }
                else if(c1==c2)
                {
                    x++;
                    elevationChange+=c2;
                    
                }
            }
             else 
             {
                 //System.out.println("row"+currY+"col"+x+"  space "+grid[currY][x]);
                 int c1_1=Math.abs(grid[currY][x]-grid[currY-1][x+1]);
                // System.out.println("up"+c1_1);
                 int c2_1=Math.abs(grid[currY][x]-grid[currY][x+1]);
                 //System.out.println("forward"+c2_1);
                 int c3_1=Math.abs(grid[currY][x]-grid[currY+1][x+1]);
                 //System.out.println("down"+c3_1);
                 if(c1_1<c2_1&&c1_1<c3_1)
                 {
                     currY--;
                     x++;
                     elevationChange+=c1_1;
                    }
                 else if(c2_1<c1_1&&c2_1<c3_1)
                 {
                     
                     x++;
                     elevationChange+=c2_1;
                    }
                 else if(c3_1<c2_1&&c3_1<c1_1)
                 {
                     currY++;
                     x++;
                     elevationChange+=c3_1;
                    }
                 else if(c1_1==c3_1&&c1_1<c2_1)
                 {
                     double rand=Math.random()*1;
                     if(rand<.5)
                     {
                         currY--;
                         x++;
                         elevationChange+=c1_1;
                         
                        }
                     else
                     {
                         currY++;
                         x++;
                         elevationChange+=c3_1;
                        }
                    }
                 else if(c2_1==c3_1&&c2_1<c1_1)
                 {
                     
                         x=x;
                         elevationChange+=c2_1;
                         
                        
                    }
                  else if(c3_1==c2_1&&c2_1==c1_1)
                  {
                      //currY++;
                      x++;
                      elevationChange+=c2_1;
                    }
                   
                    
            }
             g.fillRect(x,currY,1,1);
             
            
            }
            return elevationChange;
       }
         
                    
            
    
    //g.fillRect(x,currY,1,1);
    
    //return elevationChange; // computed change in elevation
  
  
  /**
   * @return the index of the starting row for the lowest-elevation-change path in the entire grid.
   */
  public int indexOfLowestElevPath(Graphics g){
      int lowestElevation=0;
      for(int row=0;row<grid.length;row++)
      {
          //for(int col=0;col<grid[row].length;col++)
          //{
              int path=drawLowestElevPath(g,row);
              if(path<lowestElevation)
                lowestElevation=path;
              
           //}    
          
      }
     
      return lowestElevation; // row of path with lowest elevation
  
  }
  
  /*
   public static void main(String[] args) throws FileNotFoundException
   {
  
      MapDataDrawer m=new MapDataDrawer("Colorado_844x480.dat",480,844);
    }
    */
    
}
